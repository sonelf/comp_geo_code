import java.lang.Integer;
import java.lang.Math;
import java.lang.System;
import java.util.ArrayList;
import java.util.Random;
import java.util.HashMap;
import java.lang.Double;
import java.lang.Boolean;

public class NaiveHull {
  private static final int FIRST_ELEMENT_IDX = 0;
  private ArrayList<Point> points;
  private boolean printHull;

  public NaiveHull(ArrayList<Point> points, boolean printHull){
    this.points = points;
    this.printHull = printHull;
  }

  public void computeHull(){
    long startTime = System.currentTimeMillis();
    ArrayList<Point> hullSorted = getSortedHull(points);
    //then removes colinear points:
    hullSorted = PointHelper.eliminateLinearPoints(hullSorted);

    long endTime = System.currentTimeMillis();

    System.out.println("Naive hull: ");
    System.out.println("Size of point set: "+ points.size());
    System.out.println("Size of hull: "+ hullSorted.size());
    System.out.println("Time to calculate naive hull: "+ (endTime-startTime)+ " ms");
    if(printHull){ //so we do not print humungous ones
        System.out.println(hullSorted);
    }

  }

  /*
    Returns the sorted convex hull in counter clockwise order,
    with colinear points included.
    computeHull() calls the helper function that removes the colinear points.
  */
  public ArrayList<Point> getSortedHull(ArrayList<Point> points){
    ArrayList<Pair> hullPairs = new ArrayList<Pair>();

    for(int i = 0; i < points.size(); i++){
      Point a = points.get(i);
      for(int j = 0; j < points.size(); j++){
        Point b = points.get(j);
          if(isOnHull(a,b,points)){
            hullPairs.add(new Pair(a,b));
          }
      }
    }

    //removing pairs of points with the same first point
    hullPairs = removeDuplicates(hullPairs);

    //beginning to populate the sorted points array list
    ArrayList<Point> pointsSorted = new ArrayList<Point>();
    Pair firstPair = hullPairs.get(FIRST_ELEMENT_IDX);

    Point nextStart = firstPair.getSecond();

    //adding first two points in counter clock-wise order
    Point firstStart = firstPair.getFirst();
    pointsSorted.add(firstStart);
    pointsSorted.add(nextStart);

    hullPairs.remove(firstPair);

    // n^2 search to find the next
    // counter clockwise sequence in the hull
    while(!hullPairs.isEmpty()){
      for(int i = 0; i < hullPairs.size(); i ++){
        Pair tmpPair = hullPairs.get(i);
        if(tmpPair.getFirst().equals(nextStart)){
          pointsSorted.add(tmpPair.getSecond());
          nextStart = tmpPair.getSecond();
          hullPairs.remove(tmpPair);
        }
      }
    }

    pointsSorted.remove(pointsSorted.size()-1);
    return pointsSorted;
  }

  /*
    Iterates through every pair of points
    and calculates whether they as a pair are on the hull.
  */
  public boolean isOnHull(Point a, Point b, ArrayList<Point>points){
    for(int i = 0; i < points.size(); i++){
      Point tmp = points.get(i);
      if(a.equals(b) || a.equals(tmp) || b.equals(tmp)){
        if(a.equals(b)) return false;
        continue;
      }
      else{
        if(!isLeftOf(a,b,tmp)){
          return false;
        }
      }
    }
    return true;
  }

  /*
  Calculates whether a point p is to the left of the
  line generated by points a and b.
  left includes "on" the line.

  */
  public boolean isLeftOf(Point a, Point b, Point p){
    int aX = a.getX();
    int aY = a.getY();
    int bX = b.getX();
    int bY = b.getY();
    int pX = p.getX();
    int pY = p.getY();

    double run = (double)(bX-aX); //how far away are a and b in the x-direction?
    // if slope == 0 (ie x=c), then return whether
    // the point is to the left of ab
    if(run == 0){
      if(aY > bY){
        return pX > aX;
      }
      return pX < aX;
    }

    // creating the line we use to compare p against
    double rise = (double)(bY-aY); //delta Y for line
    double slope = rise/run;

    if(slope == 0){
      if(aX > bX){
        return pY <= aY;
      }
      return pY >= aY;
    }

    double yIntercept = (bY - (slope * bX));
    double tmpY = (slope*pX)+yIntercept;
    double pyDouble = (double) pY;
    // since "left" of the line depends on the orientation of the points,
    // there are several cases to consider

    if(bX > aX && bY > aY){
      return pyDouble - tmpY >=0 ;
    }
    if(bX < aX && bY < aY){
      return pyDouble - tmpY <= 0;
    }
    if(bY < aY && bX > aX){
      return pyDouble - tmpY >= 0;
    }
    return pyDouble - tmpY <= 0;
  }

  /*
  This takes care of the case where two pairs or more points have the same starting points.
  This eliminates

  A hash map stores the String representation of the first point in a pair.
  This way, we can tell whether a point is the first point to more than one
  pair. If multiple pairs are detected,
  then the one with the smallest distance is added.

  An optimized version of this hull implementation will be able
  to recognize that if this happens, then there are colinear points,
  but for this implementation, these are two different linear sweeps
  through the points.

  */
  public ArrayList<Pair> removeDuplicates(ArrayList<Pair> items){
    ArrayList<Pair> tmp = new ArrayList<Pair>();
    HashMap<String, Double> repeatsMap = new HashMap<String, Double>();
    for(int i = 0; i < items.size(); i++){
      Pair tmpPair = items.get(i);
      String firstPoint = tmpPair.getFirst().toString();
      double tmpDist = tmpPair.getFirst().distance(tmpPair.getSecond());
      if(!repeatsMap.containsKey(firstPoint)){
        repeatsMap.put(firstPoint, tmpDist);
      }else{
        if(repeatsMap.get(firstPoint) > tmpDist ){
          repeatsMap.put(firstPoint, tmpDist);
        }
      }

    }

    for(int i = 0; i < items.size(); i++){
      Pair tmpPair = items.get(i);
      String firstPoint = tmpPair.getFirst().toString();
      double tmpDist = tmpPair.getFirst().distance(tmpPair.getSecond());

      if(repeatsMap.get(firstPoint)==tmpDist){
        tmp.add(tmpPair);
      }
    }
    return tmp;
  }

}
