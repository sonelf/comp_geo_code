import java.lang.Integer;
import java.lang.Math;
import java.lang.System;
import java.util.ArrayList;
import java.util.Random;
import java.util.HashMap;
import java.lang.Double;
import java.lang.Boolean;

public class NaiveHull {
  public static final int FIRST_ELEMENT_IDX = 0;

  public static void computeHull(ArrayList<Point> points, boolean printHull){
    long startTime = System.currentTimeMillis();
    ArrayList<Point> hullSorted = getSortedHull(points);
    //then removes colinear points:
    hullSorted = eliminateLinearPoints(hullSorted);

    long endTime = System.currentTimeMillis();

    System.out.println("Naive hull: ");
    System.out.println("Size of point set: "+ points.size());
    System.out.println("Size of hull: "+ hullSorted.size());
    System.out.println("Time to calculate naive hull: "+ (endTime-startTime)+ " ms");
    if(printHull){ //so we do not print humungous ones
        System.out.println(hullSorted);
    }

  }

  /*
    Returns the sorted convex hull in counter clockwise order,
    with colinear points included.
    computeHull() calls the helper function that removes the colinear points.
  */
  public static ArrayList<Point> getSortedHull(ArrayList<Point> points){
    ArrayList<Pair> hullPairs = new ArrayList<Pair>();

    for(int i = 0; i < points.size(); i++){
      Point a = points.get(i);
      for(int j = 0; j < points.size(); j++){
        Point b = points.get(j);
          if(isOnHull(a,b,points)){
            hullPairs.add(new Pair(a,b));
          }
      }
    }

    //removing pairs of points with the same first point
    hullPairs = removeDuplicates(hullPairs);

    //beginning to populate the sorted points array list
    ArrayList<Point> pointsSorted = new ArrayList<Point>();
    Pair firstPair = hullPairs.get(FIRST_ELEMENT_IDX);

    Point nextStart = firstPair.getSecond();

    //adding first two points in counter clock-wise order
    Point firstStart = firstPair.getFirst();
    pointsSorted.add(firstStart);
    pointsSorted.add(nextStart);

    hullPairs.remove(firstPair);

    // n^2 search to find the next
    // counter clockwise sequence in the hull
    while(!hullPairs.isEmpty()){
      for(int i = 0; i < hullPairs.size(); i ++){
        Pair tmpPair = hullPairs.get(i);
        if(tmpPair.getFirst().equals(nextStart)){
          pointsSorted.add(tmpPair.getSecond());
          nextStart = tmpPair.getSecond();
          hullPairs.remove(tmpPair);
        }
      }
    }

    pointsSorted.remove(pointsSorted.size()-1);
    return pointsSorted;
  }

  /*
    Iterates through every pair of points
    and calculates whether they as a pair are on the hull.
  */
  public static boolean isOnHull(Point a, Point b, ArrayList<Point>points){
    for(int i = 0; i < points.size(); i++){
      Point tmp = points.get(i);
      if(a.equals(b) || a.equals(tmp) || b.equals(tmp)){
        if(a.equals(b)) return false;
        continue;
      }
      else{
        if(!isLeftOf(a,b,tmp)){
          return false;
        }
      }
    }
    return true;
  }

  /*
  Calculates whether a point p is to the left of the
  line generated by points a and b.
  left includes "on" the line.

  */
  public static boolean isLeftOf(Point a, Point b, Point p){
    int aX = a.getX();
    int aY = a.getY();
    int bX = b.getX();
    int bY = b.getY();
    int pX = p.getX();
    int pY = p.getY();

    double run = (double)(bX-aX); //how far away are a and b in the x-direction?
    // if slope == 0 (ie x=c), then return whether
    // the point is to the left of ab
    if(run == 0){
      if(aY > bY){
        return pX > aX;
      }
      return pX < aX;
    }

    // creating the line we use to compare p against
    double rise = (double)(bY-aY); //delta Y for line
    double slope = rise/run;

    if(slope == 0){
      if(aX > bX){
        return pY <= aY;
      }
      return pY >= aY;
    }

    double yIntercept = (bY - (slope * bX));
    double tmpY = (slope*pX)+yIntercept;
    double pyDouble = (double) pY;
    // since "left" of the line depends on the orientation of the points,
    // there are several cases to consider

    if(bX > aX && bY > aY){
      return pyDouble - tmpY >=0 ;
    }
    if(bX < aX && bY < aY){
      return pyDouble - tmpY <= 0;
    }
    if(bY < aY && bX > aX){
      return pyDouble - tmpY >= 0;
    }
    return pyDouble - tmpY <= 0;
  }

  /*
  This takes care of the case where two pairs or more points have the same starting points.
  This eliminates

  A hash map stores the String representation of the first point in a pair.
  This way, we can tell whether a point is the first point to more than one
  pair. If multiple pairs are detected,
  then the one with the smallest distance is added.

  An optimized version of this hull implementation will be able
  to recognize that if this happens, then there are colinear points,
  but for this implementation, these are two different linear sweeps
  through the points.

  */
  public static ArrayList<Pair> removeDuplicates(ArrayList<Pair> items){
    ArrayList<Pair> tmp = new ArrayList<Pair>();
    HashMap<String, Double> repeatsMap = new HashMap<String, Double>();
    for(int i = 0; i < items.size(); i++){
      Pair tmpPair = items.get(i);
      String firstPoint = tmpPair.getFirst().toString();
      double tmpDist = tmpPair.getFirst().distance(tmpPair.getSecond());
      if(!repeatsMap.containsKey(firstPoint)){
        repeatsMap.put(firstPoint, tmpDist);
      }else{
        if(repeatsMap.get(firstPoint) > tmpDist ){
          repeatsMap.put(firstPoint, tmpDist);
        }
      }

    }

    for(int i = 0; i < items.size(); i++){
      Pair tmpPair = items.get(i);
      String firstPoint = tmpPair.getFirst().toString();
      double tmpDist = tmpPair.getFirst().distance(tmpPair.getSecond());

      if(repeatsMap.get(firstPoint)==tmpDist){
        tmp.add(tmpPair);
      }
    }
    return tmp;
  }

  /*
  Helper method that removes linear points.
  This is being done now because the points are now in counter clockwise order.

  */
  public static ArrayList<Point> eliminateLinearPoints(ArrayList<Point> items){
    for(int i = 0; i < items.size()-2;i++){
      Point ptA = items.get(i);
      Point ptB = items.get(i+1);
      Point ptC = items.get(i+2);
      if(isOnLine(ptA,ptC,ptB) && !ptA.equals(ptB) && !ptA.equals(ptC) && !ptB.equals(ptC) && isInMiddle(ptA,ptC,ptB)){
        items.remove(ptB);
      }

    }

    //manually have to check whether we need to delete the first and last one
    //this assumes valid input, ie, there must be at least 3 points in items
    Point last = items.get(items.size()-1);
    Point secondLast = items.get(items.size()-2);
    Point first = items.get(0);

    if(isOnLine(secondLast,first,last) && isInMiddle(secondLast,first,last)){
      items.remove(last);
    }

    //updating last
    last = items.get(items.size()-1);
    Point second = items.get(1);
    if(isOnLine(last,second,first) && isInMiddle(last,second,first)){
      items.remove(first);
    }
    return items;
  }
  /*
  Naive part to implemeting whether two points are colinear
  Returns whether point p is in between the two points a and b.
  We assume that when we call this function that all three points are colinear

  if a point is in the middle of two points on a line, there are only so many options it could be,
  depending on the where the a and b are and how the line is oriented.

  We determine which point is the upper point and then compare it against the lower point.
  Sometimes if the point is not in the middle it will not apply to any of these cases,
  in which case we return false.

  */
  public static boolean isInMiddle(Point a, Point b, Point p){
    int aX = a.getX();
    int aY = a.getY();
    int bX = b.getX();
    int bY = b.getY();
    int pX = p.getX();
    int pY = p.getY();

    if(aX -pX >=0  && aY - pY >= 0){
      return (pX - bX >= 0) && (pY - bY >= 0);
    }
    else if(bX - pX >= 0 && bY - pY >=0 ){
      return (pX - aX >= 0)&&(pY - aY >= 0);
    }
    else if((aY -pY )>= 0 && (aX - pX) <= 0){
      return ((pX - bX) <=0) && (pY - bY >= 0);
    }
    else if((bX - pX <=0) && (bY > pY)){
      return (pY - aY) >= 0 && (pX - aX <= 0);
    }
    return false;
  }

  public static boolean isOnLine(Point a, Point b, Point p){
    int aX = a.getX();
    int aY = a.getY();
    int bX = b.getX();
    int bY = b.getY();
    int pX = p.getX();
    int pY = p.getY();

    double run = (double)(bX-aX); //how far away are a and b in the x-direction?

    if(run == 0){ // if slope is zero (ie it's just x = c),
    //then check if the x-coordinate of p is the same
      return pX == aX;

    }
    // creating the line we use to compare p against
    double rise = (double)(bY-aY); //delta Y for line
    double slope = rise/run;

    double yIntercept = (bY - (slope * bX));
    double tmpY = (slope*pX)+yIntercept;

    return pY == tmpY;
  }

}
